<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>

        /* Full-screen overlay styles */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* Dark semi-transparent background */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 9999; /* Ensure it overlays everything */
            color: white;
        }

        #overlay h2 {
            margin-bottom: 20px;
            font-size: 24px;
        }

        #playerNameInput {
            padding: 10px;
            font-size: 16px;
            margin-bottom: 20px;
            width: 60%;
            max-width: 300px;
            text-align: center;
            border-radius: 5px;
            border: none;
        }

        #joinButton {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }

        #joinButton:hover {
            background-color: #45a049;
        }

        /* Admin control button styles */
        #adminControls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none; /* Hidden by default */
            z-index: 60; /* Video below A-Frame */
        }

        .admin-button {
            padding: 10px 15px;
            font-size: 14px;
            margin: 5px;
            background-color: #FF5733;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 60; /* Video below A-Frame */
        }



        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #000; /* Black background to blend with A-Frame */
            font-family: Arial, sans-serif;
            margin: 0; /* Reset default margin */
            overflow: hidden; /* Hide overflow */
        }

        video {
            width: 100%;
            height: auto;
            position: absolute; /* Position video absolutely */
            top: 0;
            left: 0;
            z-index: 0; /* Video below A-Frame */
        }

        h1 {
            position: absolute; /* Position the heading over the A-Frame */
            top: 20px; /* Space from the top */
            z-index: 10; /* Ensure it stays above the A-Frame */
            color: #fff; /* Change heading color for visibility */
            font-size: 24px; /* Base font size */
        }


        iframe {
            border: none; /* Removes default border */
            border-radius: 8px; /* Optional: Adds rounded corners */
            width: 560px; /* Default width */
            height: 315px; /* Default height */
            position: absolute; /* Absolute positioning */
            top: 80px; /* Space from the top */
            right: 10px;
            z-index: 20; /* Higher z-index to sit above the A-Frame */
        }

        #support-counts {
            position: absolute;
            top: 80px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 21; /* Space from the top */
        }

        #joystick {
            position: fixed;
            bottom: 100px; /* Distance from the bottom of the screen */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Adjust to center precisely */
            width: 150px; /* Default joystick size */
            height: 150px; /* Default joystick size */
            z-index: 30; /* Ensure it appears above other elements */
        }

        a-scene {
            position: absolute; /* Position the A-Frame absolutely */
            top: 0; /* Align to the top */
            left: 0; /* Align to the left */
            width: 100%; /* Full width for A-Frame */
            height: 100%; /* Full height for A-Frame */
            z-index: 1; /* Lower z-index to place behind other elements */
        }

        /* Media Queries for Responsive Design */
        @media (max-width: 768px) {
            h1 {
                font-size: 20px; /* Smaller font size for mobile */
                top: 10px; /* Adjust position for mobile */
            }


            iframe {
                width: 45%; /* width on mobile */
                height: auto; /* Maintain aspect ratio */
                top: 30px; /* Adjust space from the top */
            }

            #support-counts {
                width: 45%; /* width on mobile */
                height: auto; /* Maintain aspect ratio */
                top: 30px; /* Adjust space from the top */
            }
            
            #joystick {
                width: 60px; /* Smaller joystick size for mobile */
                height: 60px; /* Smaller joystick size for mobile */
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 18px; /* Further reduce font size */
            }

            #joystick {
                width: 80px; /* Even smaller joystick */
                height: 80px; /* Even smaller joystick */
            }
        }

    </style>
    <!-- Include A-Frame library -->
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <!-- Include Nipple.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.8.0/nipplejs.min.js"></script>
    <!-- Include Socket.IO library -->
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>

</head>
<body>

    <!-- Full-screen overlay for name input -->
    <div id="overlay">
        <h2>Enter Your Name</h2>
        <input type="text" id="playerNameInput" placeholder="Your Name">
        <button id="joinButton" onclick="submitName()">Join</button>
    </div>

    <!-- Admin controls only for "camera_master" -->
    <div id="adminControls">
        <button class="admin-button" onclick="triggerSpecialAction()">Special Action</button>
        <button class="admin-button" onclick="toggleFeature()">Toggle Feature</button>
    </div>

    <!-- A-Frame Scene -->
    <a-scene embedded>

        <!-- Lights -->
        <a-light type="ambient" color="#FFF" intensity="1"></a-light>
        <a-light type="directional" color="#FFF" intensity="1" position="0 2 0" castShadow="true"></a-light>


        <!-- GLTF Model 1 -->
        <a-entity gltf-model="models/Testarena.glb"
                    position="0 0.5 0"
                    scale="1 1 1"
                    material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                    shadow="receive: true; cast: true">
        </a-entity>


        <!-- Model visibility wrapper - initially hidden -->
        <a-entity id="modelContainer" visible="false">
            <!-- GLTF Model 2 -->
            <a-entity gltf-model="models/Testarenafloor.glb"
                      position="0 0.5 0"
                      scale="1 1 1"
                      material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                      shadow="receive: true; cast: true"
                      color="#4CC3D9">
            </a-entity>
       
            <!-- Objects that change color when looked at -->
            <a-box class="interactive-box" position="13 5 25" color="purple" scale="7 7 7"></a-box>
            <a-box class="interactive-box" position="-13 5 25" color="purple" scale="7 7 7"></a-box>
            <a-box class="interactive-box" position="0  5 45" color="purple" scale="7 7 7"></a-box>


            <a-box class="interactive-box" position="13  5 -25" color="lightblue" scale="7 7 7"></a-box>
            <a-box class="interactive-box" position="40  5 -25" color="lightblue" scale="7 7 7"></a-box>
            <a-box class="interactive-box" position="27  5 0" color="lightblue" scale="7 7 7"></a-box>

            <a-box class="interactive-box" position="-13 5 -25" color="darkblue" scale="7 7 7"></a-box>
            <a-box class="interactive-box" position="-40 5 -25" color="darkblue" scale="7 7 7"></a-box>
            <a-box class="interactive-box" position="-27 5 0" color="darkblue" scale="7 7 7"></a-box>

        </a-entity>


        <!-- Player Entity -->
        <a-entity id="player" position="0 1 0">
            <!-- Player sphere at height 1 -->
            <a-sphere id="player-sphere" radius="0.5" color="#FF0000"></a-sphere> <!-- Optional player sphere -->
            <!-- Camera with raycaster at height 40 -->
            <a-camera position="0 40 0" raycaster="objects: .interactive-box; showLine: false; far: 200">
            <!-- Text to display the player name above the avatar -->
            <a-text id="playerNameText" value="" position="0 2 -1" align="center" color="white"></a-text>
            </a-entity>

        <!-- Points in the scene (with visual spheres) -->
        <a-entity id="point1" position="-10 2 10">
            <a-sphere radius="0.01" color="#00FF00"></a-sphere> <!-- Green Sphere for Point 2 -->
        </a-entity>
        <a-entity id="point2" position="10 2 10">
            <a-sphere radius="0.01" color="#FFFF00"></a-sphere> <!-- Yellow Sphere for Point 3 -->
        </a-entity>
        <a-entity id="point3" position="0 2 -10">
            <a-sphere radius="0.01" color="#0000FF"></a-sphere> <!-- Blue Sphere for Point 1 -->
        </a-entity>



    </a-scene>


    <iframe 
        src="https://player.twitch.tv/?channel=flo0oo0oo&parent=ar-space.onrender.com" 
        allowfullscreen="false">
    </iframe>


    <video id="webcam" autoplay playsinline></video>



    <div id="support-counts">
        <p id="None">CURRENT SCORE</p>
        <p id="point1Count">Player 1 Supporters: 0</p>
        <p id="point2Count">Player 2 Supporters: 0</p>
        <p id="point3Count">Player 3 Supporters: 0</p>
    </div>

    <div id="joystick"></div>
    <div id="closest-player">Closest Player: None</div> <!-- New text object for closest player -->

    <script>

        const socket = io(window.location.origin);

        // Function to handle name submission
        function submitName() {
            const playerName = document.getElementById('playerNameInput').value.trim();

            if (playerName === '') {
                alert("Please enter a name.");
                return;
            }

            document.getElementById('overlay').style.display = 'none';
            document.getElementById('playerNameText').setAttribute('value', playerName);

            if (playerName === 'camera_master') {
                document.getElementById('adminControls').style.display = 'block';
            }
        }
        
        
        function triggerSpecialAction() {
            const modelContainer = document.getElementById('modelContainer');
            
            // Get the current visibility (convert string to boolean)
            const currentVisibility = modelContainer.getAttribute('visible');
            
            // Toggle the visibility
            const newVisibility = !currentVisibility; // Just toggle the boolean value
            
            // Set the new visibility (true/false, not string)
            modelContainer.setAttribute('visible', newVisibility);

            // Send a message to other clients to sync the visibility
            socket.emit('toggleModelVisibility', newVisibility);
        }



        // Client-side (JavaScript)
        socket.on('updateModelVisibility', (newVisibility) => {
            const modelContainer = document.getElementById('modelContainer');
            modelContainer.setAttribute('visible', newVisibility);
        });


        // When camera_master toggles visibility, emit to all clients
        socket.on('toggleModelVisibility', () => {
            const visibilityData = {
                modelId: 'modelContainer', // replace with actual model ID
                visibility: true // or false, depending on desired state
            };
            io.emit('updateModelVisibility', visibilityData);
        });




        AFRAME.registerComponent('rotate', {
                schema: {
                    speed: {type: 'number', default: 1} // Rotation speed
                },
                tick: function () {
                    const el = this.el; // Reference to the entity
                    const data = this.data; // Component data
                    el.object3D.rotation.y += data.speed * 0.01; // Adjust speed as needed
                }
            });

        // Access the user's webcam
        const video = document.querySelector('#webcam');

        navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment' } // 'user' for front camera, 'environment' for rear camera
        })
        .then(function(stream) {
            video.srcObject = stream;
            video.play();
        })
        .catch(function(err) {
            console.error("Error accessing webcam: " + err);
        });

            
            

        let players = {};
        const player = document.getElementById('player'); // Get player entity
        const camera = player.querySelector('a-camera');  // Camera within player
        const closestPlayerDiv = document.getElementById('closest-player'); // Div for closest player info

        // Points in the scene
        const points = [
            { id: 'point1', element: document.getElementById('point1') },
            { id: 'point2', element: document.getElementById('point2') },
            { id: 'point3', element: document.getElementById('point3') }
        ];

        // Handle the current players on initial connection
        socket.on('currentPlayers', (serverPlayers) => {
            for (const id in serverPlayers) {
                if (!players[id]) {
                    createPlayerSphere(id, serverPlayers[id].position);
                }
            }
        });

        // Handle new player joining
        socket.on('newPlayer', (data) => {
            createPlayerSphere(data.id, data.position);
        });

        // Handle player movement
        socket.on('move', (data) => {
            if (players[data.id]) {
                players[data.id].setAttribute('position', `${data.position.x} ${data.position.y} ${data.position.z}`);
            }
        });

        // Handle player disconnect
        socket.on('removePlayer', (id) => {
            if (players[id]) {
                players[id].parentNode.removeChild(players[id]);
                delete players[id];
            }
        });

        // Listen for support point updates from the server
        socket.on('supportPointUpdate', (data) => {
            const { pointCounts } = data;

            // Update the HTML with the latest counts
            document.getElementById('point1Count').textContent = `Player 1 Supporters: ${pointCounts.point1}`;
            document.getElementById('point2Count').textContent = `Player 2 Supporters: ${pointCounts.point2}`;
            document.getElementById('point3Count').textContent = `Player 3 Supporters: ${pointCounts.point3}`;
        });




        // Create a sphere for each player
        function createPlayerSphere(id, position) {
            const sphere = document.createElement('a-sphere');
            
            // Check if the current player is the local player
            if (id === socket.id) {
                sphere.setAttribute('color', 'green'); // Local player color
                sphere.setAttribute('radius', '1');
            } else {
                sphere.setAttribute('color', 'red'); // Other players color
                sphere.setAttribute('radius', '0.5');
            }
            
            sphere.setAttribute('position', position);
            sphere.setAttribute('id', id);
            document.querySelector('a-scene').appendChild(sphere);
            players[id] = sphere; // Store the sphere for future reference
        }

        // Calculate and display the closest point
        function updateClosestPoint() {
            const playerPos = player.getAttribute('position');
            let closestPoint = null;
            let closestDistance = Infinity;

            // Iterate over defined points to find the closest one
            points.forEach(point => {
                const pointPos = point.element.getAttribute('position');
                const distance = Math.sqrt(
                    Math.pow(pointPos.x - playerPos.x, 2) +
                    Math.pow(pointPos.y - playerPos.y, 2) +
                    Math.pow(pointPos.z - playerPos.z, 2)
                );

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPoint = point.id; // Keep track of the closest point
                }
            });

        
            // Send the closest point to the server
            socket.emit('updateSupportPoint', {
                playerId: socket.id,  // Send player ID to the server
                supportPoint: closestPoint // Send closest point ID
            });
        
        }

        // Update closest point every second
        setInterval(updateClosestPoint, 2000);


    
        // Joystick setup
        const joystick = nipplejs.create({
            zone: document.getElementById('joystick'),
            mode: 'static',
            position: { left: '50%', bottom: '20px' },
            size: 150,
            color: 'red'
        });
    
        let joystickActive = false; // Track joystick activity
        let currentMoveDirection = new THREE.Vector3(); // Store the current move direction

        // Joystick movement handling
        joystick.on('move', (evt, data) => {
            joystickActive = true; // Joystick is being manipulated
            const moveDistance = 0.6; // Movement speed
            const angle = data.angle.degree;

            const rad = angle * (Math.PI / 180); // Convert to radians

            // Get the camera's world direction
            const cameraDirection = new THREE.Vector3();
            camera.object3D.getWorldDirection(cameraDirection);
            
            // Project the camera direction onto the X-Z plane (ignore Y)
            cameraDirection.y = 0; // Set Y to zero for 2D movement
            cameraDirection.normalize(); // Normalize to get a unit vector

            // Calculate the movement direction based on joystick input
            currentMoveDirection.set(
                cameraDirection.z * Math.cos(rad) + cameraDirection.x * -Math.sin(rad), // Swapped to make 'up' move left
                0, // Keep Y at 0 for 2D movement
                cameraDirection.z * -Math.sin(rad) - cameraDirection.x * Math.cos(rad) // Swapped to make 'down' move right
            );
        });

        // Event when joystick is released
        joystick.on('end', () => {
            joystickActive = false; // Joystick is not being manipulated
            currentMoveDirection.set(0, 0, 0); // Reset direction
        });

        // Update loop
        function update() {
            if (joystickActive) {
                const moveDistance = 0.25; // Movement speed

                // Update player position based on the calculated direction
                player.object3D.position.x += currentMoveDirection.x * moveDistance;
                player.object3D.position.z += currentMoveDirection.z * moveDistance;

                // Update the player's sphere position to match the player entity
                const playerSphere = players[socket.id]; // Get the sphere associated with this player
                if (playerSphere) {
                    playerSphere.setAttribute('position', `${player.object3D.position.x} ${player.object3D.position.y} ${player.object3D.position.z}`);
                }

                // Emit the new position to the server
                socket.emit('move', { id: socket.id, position: player.object3D.position });
            }

            requestAnimationFrame(update); // Continue the update loop
        }

        // Start the update loop
        update();





        // Select all box objects with the class 'interactive-box'
        const boxes = document.querySelectorAll('.interactive-box');

        // Loop through each box and add event listeners
        boxes.forEach((box) => {
            let isIntersected = false;

            // Store the original color in a dataset attribute
            box.dataset.originalColor = box.getAttribute('color');


            // Event listener for intersection
            box.addEventListener('raycaster-intersected', () => {
                box.setAttribute('material', 'color', 'yellow');
            });


            // Event listener for clearing intersection
            box.addEventListener('raycaster-intersected-cleared', () => {
                // Reset to original color
                const originalColor = box.dataset.originalColor;
                box.setAttribute('material', 'color', originalColor);
            });

            // Add click listener to change color to red temporarily
            box.addEventListener('click', () => {
                if (isIntersected) { // Only allow tapping when looked at directly
                    box.setAttribute('material', 'color', 'red');
                    setTimeout(() => {
                        // Return to blue if still intersected; otherwise, yellow
                        box.setAttribute('material', 'color', isIntersected ? 'blue' : 'yellow');
                    }, 3000); // 3-second delay
                }
            });
        });

        
        console.log('DOM fully loaded and parsed');
        console.log('Emitting position:', player.object3D.position);
        console.log('Received move for ID:', data.id, 'Position:', data.position);

    </script>
</body>
</html>