<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Multiplayer VR Sample</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/nipplejs/dist/nipplejs.css" />
    <script src="https://unpkg.com/nipplejs/dist/nipplejs.js"></script>
    <style>
        #joystick {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
        }

        video {
            /* display: none; */ /* Uncomment to show video */
            width: 640px; /* Set appropriate width */
            height: auto; /* Set height to auto */
            position: absolute; /* Keep it hidden but still rendering */
            top: -9999px; /* Move it off-screen */
        }

    </style>
</head>
<body>
    <a-scene fog="type: linear; color: #AAB7B8; near: 10; far: 50">

        <a-assets>
            <img id="groundTexture" src="path/to/ground-texture.jpg">
            <img id="skyTexture" src="path/to/skybox.jpg">
        </a-assets>

        <!-- Sky and Lighting -->
        <a-sky src="#skyTexture"></a-sky>
        <a-light type="ambient" color="#888"></a-light>
        <a-light type="directional" position="10 10 0" intensity="0.8"></a-light>

        <!-- Ground Plane -->
        <a-plane rotation="-90 0 0" width="30" height="30" src="#groundTexture" repeat="10 10"></a-plane>

        <!-- Video Stream Plane -->
        <a-plane id="videoPlane" rotation="0 0 0" width="5" height="3" position="0 2 -5" visible="true"></a-plane>

        <!-- Load the model -->
        <a-entity gltf-model="models/Test.glb" position="0 0 0" scale="0.5 0.5 0.5"></a-entity>

        <!-- Player template -->
        <a-entity id="player" position="0 1.6 0">
            <a-camera></a-camera>
            <a-text id="directionText" value="Direction: (0, 0, 0)" position="-3 3 -5" color="#FFF" align="center"></a-text>
        </a-entity>

    </a-scene>

    <div id="joystick"></div>
    <video id="videoElement" autoplay></video>

    <script>
        const socket = io(window.location.origin);
        let players = {};
        let firstPlayerId = null; // To keep track of the first player who connects
        const player = document.getElementById('player');
        const camera = player.querySelector('a-camera');
        const videoElement = document.getElementById('videoElement');
        const videoPlane = document.getElementById('videoPlane');

        // Joystick setup
        const joystick = nipplejs.create({
            zone: document.getElementById('joystick'),
            mode: 'static',
            position: { left: '50%', bottom: '50%' },
            size: 100,
            color: 'blue'
        });

        // Function to get the camera's forward and right direction vectors
        function getCameraDirection() {
            const cameraRotation = camera.getAttribute('rotation');
            const yaw = THREE.MathUtils.degToRad(cameraRotation.y); // Convert yaw to radians

            // Calculate forward and right vectors based on yaw
            const forwardVector = new THREE.Vector3(Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
            const rightVector = new THREE.Vector3(forwardVector.z, 0, -forwardVector.x).normalize(); // Perpendicular to forward

            return { forward: forwardVector, right: rightVector };
        }

        // Joystick movement handler
        joystick.on('move', (evt, data) => {
            // Get the camera's yaw (rotation around the y-axis)
            const cameraRotation = camera.getAttribute('rotation');
            const yaw = THREE.MathUtils.degToRad(cameraRotation.y); // Convert yaw to radians

            // Calculate the forward direction based on camera's yaw
            const forwardVector = new THREE.Vector2(Math.sin(yaw), -Math.cos(yaw)); // Camera's forward in 2D

            // Calculate the joystick movement vector
            const joystickVector = new THREE.Vector2(data.vector.x, data.vector.y); // x = left/right, y = forward/backward

            // Adjust joystick input to movement vector
            const movementVector = forwardVector.clone().multiplyScalar(joystickVector.y); // Move forward/backward
            const rightVector = new THREE.Vector2(forwardVector.y, -forwardVector.x); // Perpendicular to forward for right movement

            // Move right/left based on joystick input
            movementVector.add(rightVector.multiplyScalar(joystickVector.x)); // Add right movement

            // Get the current player position
            const playerPos = player.getAttribute('position');

            // Update position based on the movement vector
            const newPosition = {
                x: playerPos.x - movementVector.x * 0.1, // Scale movement for control
                y: playerPos.y, // Maintain height
                z: playerPos.z + movementVector.y * 0.1 // Scale movement for control
            };

            // Update the player's position
            player.setAttribute('position', newPosition);

            // Send updated position to server
            sendMove(newPosition);
        });

        // Function to start streaming video
        async function startStreaming() {
            if (!firstPlayerId) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    videoElement.srcObject = stream;

                    // Play the video to ensure it is rendering
                    videoElement.play();

                    // Create a new video texture
                    const videoTexture = new THREE.VideoTexture(videoElement);
                    videoPlane.setAttribute('material', 'src', videoTexture);

                    // Make sure the video plane is visible
                    videoPlane.setAttribute('visible', true);
                    videoPlane.setAttribute('material', 'side', 'double'); // Ensure it's visible from both sides
                } catch (err) {
                    console.error('Error accessing webcam: ', err);
                }
            }
        }

        // Initialize and update player positions in scene
        socket.on('currentPlayers', (currentPlayers) => {
            players = currentPlayers;
            Object.keys(players).forEach(id => {
                if (id !== socket.id) addPlayer(id, players[id].position);
            });
        });

        // Player management: add, remove, and update players in scene
        socket.on('newPlayer', (data) => {
            addPlayer(data.id, data.position);
            if (!firstPlayerId) {
                firstPlayerId = data.id; // Set the first player who connects
                startStreaming(); // Start streaming for the first player that connects
            }
        });
        socket.on('removePlayer', (id) => {
            const player = document.getElementById(id);
            if (player) player.remove();
            if (id === firstPlayerId) {
                // Reset the streaming flag if the first player disconnects
                firstPlayerId = null;
                videoPlane.setAttribute('visible', false); // Hide the video plane
            }
        });
        socket.on('move', (data) => {
            const otherPlayer = document.getElementById(data.id);
            if (otherPlayer) {
                otherPlayer.setAttribute('position', data.position);
            }
        });

        function addPlayer(id, position) {
            const el = document.createElement('a-sphere');
            el.setAttribute('id', id);
            el.setAttribute('position', position);
            el.setAttribute('radius', 0.3);
            el.setAttribute('color', '#FF0000');

            const nameEl = document.createElement('a-text');
            nameEl.setAttribute('value', id);
            nameEl.setAttribute('position', '0 0.5 0');
            nameEl.setAttribute('color', '#FFFFFF');

            el.appendChild(nameEl);
            document.querySelector('a-scene').appendChild(el);
        }

        function sendMove(position) {
            socket.emit('move', { position });
        }

        // Sync player position on screen to ensure continuous updates
        setInterval(() => {
            const pos = player.getAttribute('position');
            player.setAttribute('position', pos);
        }, 100);
    </script>

</body>
</html>
