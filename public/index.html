<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #000; /* Black background to blend with A-Frame */
            font-family: Arial, sans-serif;
            margin: 0; /* Reset default margin */
            overflow: hidden; /* Hide overflow */
        }

        h1 {
            position: absolute; /* Position the heading over the A-Frame */
            top: 20px; /* Space from the top */
            z-index: 10; /* Ensure it stays above the A-Frame */
            color: #fff; /* Change heading color for visibility */
            font-size: 24px; /* Base font size */
        }

        iframe {
            border: none; /* Removes default border */
            border-radius: 8px; /* Optional: Adds rounded corners */
            width: 560px; /* Default width */
            height: 315px; /* Default height */
            position: absolute; /* Absolute positioning */
            top: 80px; /* Space from the top */
            z-index: 20; /* Higher z-index to sit above the A-Frame */
        }

        #joystick {
            position: fixed;
            bottom: 100px; /* Distance from the bottom of the screen */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Adjust to center precisely */
            width: 150px; /* Default joystick size */
            height: 150px; /* Default joystick size */
            z-index: 30; /* Ensure it appears above other elements */
        }

        #scoreboard {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        a-scene {
            position: absolute; /* Position the A-Frame absolutely */
            top: 0; /* Align to the top */
            left: 0; /* Align to the left */
            width: 100%; /* Full width for A-Frame */
            height: 100%; /* Full height for A-Frame */
            z-index: 1; /* Lower z-index to place behind other elements */
        }

        /* Media Queries for Responsive Design */
        @media (max-width: 768px) {
            h1 {
                font-size: 20px; /* Smaller font size for mobile */
                top: 10px; /* Adjust position for mobile */
            }

            iframe {
                width: 60%; /* width on mobile */
                height: auto; /* Maintain aspect ratio */
                top: 50px; /* Adjust space from the top */
            }

            #joystick {
                width: 100px; /* Smaller joystick size for mobile */
                height: 100px; /* Smaller joystick size for mobile */
            }

            #scoreboard {
                padding: 8px; /* Adjust padding for mobile */
                font-size: 14px; /* Smaller font size for scoreboard */
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 18px; /* Further reduce font size */
            }

            #joystick {
                width: 80px; /* Even smaller joystick */
                height: 80px; /* Even smaller joystick */
            }

            #scoreboard {
                font-size: 12px; /* Smaller font size for scoreboard */
            }
        }

    </style>
    </style>
    <!-- Include A-Frame library -->
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <!-- Include Nipple.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.8.0/nipplejs.min.js"></script>
    <!-- Include Socket.IO library -->
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
</head>

</head>
<body>
    <iframe 
        src="https://player.twitch.tv/?channel=flo0oo0oo&parent=ar-space.onrender.com" 
        allowfullscreen="false">
    </iframe>
    
    <!-- ar-space.onrender.com instead of localhost! -->

    <!-- A-Frame Scene -->
    <a-scene embedded>

        
        <!-- Lights -->
        <a-light type="ambient" color="#FFF" intensity="3"></a-light>
        <a-light type="directional" color="#FFF" intensity="1" position="-1 2 1" castShadow="true"></a-light>
        
        
        <!-- Load the model -->
        <a-entity 
            gltf-model="models/Test.glb" 
            position="0 0.5 0" 
            scale="1 1 1" 
            material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1" 
            shadow="receive: true; cast: true">
        </a-entity>

        <!-- Video planes for streaming -->
        <a-plane id="videoPlane" rotation="0 0 0" width="5" height="3" position="0 4 -10" visible="false" class="video-plane"></a-plane>
        <a-plane id="videoPlane1" rotation="0 120 0" width="5" height="3" position="-10 4 10" visible="false" class="video-plane"></a-plane>
        <a-plane id="videoPlane2" rotation="0 -120 0" width="5" height="3" position="10 4 10" visible="false" class="video-plane"></a-plane>

        <!-- Sky -->
        <a-sky color="#E9CFC7"></a-sky>

        <!-- Player Entity -->
        <a-entity id="player" position="0 1 0">  <!-- Player sphere at height 1 -->
            <a-sphere id="player-sphere" radius="0.5" color="#FF0000"></a-sphere> <!-- Optional player sphere -->
            <a-camera position="0 25 0"></a-camera>  <!-- Camera at height 15 (1 + 14) -->
        </a-entity>

        <!-- Points in the scene (with visual spheres) -->
        <a-entity id="point3" position="0 2 -10">
            <a-sphere radius="1" color="#0000FF"></a-sphere> <!-- Blue Sphere for Point 1 -->
        </a-entity>
        <a-entity id="point1" position="-10 2 10">
            <a-sphere radius="1" color="#00FF00"></a-sphere> <!-- Green Sphere for Point 2 -->
        </a-entity>
        <a-entity id="point2" position="10 2 10">
            <a-sphere radius="1" color="#FFFF00"></a-sphere> <!-- Yellow Sphere for Point 3 -->
        </a-entity>

        <a-text id="distance-text" 
                 value="Distance to Origin: 0" 
                 position="0 3 -2" 
                 align="center" 
                 color="#FFF" 
                 width="6" 
                 scale="10 10 4">
        </a-text>

    </a-scene>

    <div id="joystick"></div>
    </div>
    
    <script>
        const socket = io(window.location.origin);
        let players = {};
        const player = document.getElementById('player'); // Get player entity
        const camera = player.querySelector('a-camera');  // Camera within player
    
        // Handle the current players on initial connection
        socket.on('currentPlayers', (serverPlayers) => {
            for (const id in serverPlayers) {
                if (!players[id]) {
                    createPlayerSphere(id, serverPlayers[id].position);
                }
            }
        });
    
        // Handle new player joining
        socket.on('newPlayer', (data) => {
            createPlayerSphere(data.id, data.position);
        });
    
        // Handle player movement
        socket.on('move', (data) => {
            if (players[data.id]) {
                players[data.id].setAttribute('position', `${data.position.x} ${data.position.y} ${data.position.z}`);
            }
        });
    
        // Handle player disconnect
        socket.on('removePlayer', (id) => {
            if (players[id]) {
                players[id].parentNode.removeChild(players[id]);
                delete players[id];
            }
        });

        socket.on('playerDisconnected', (id) => {
            console.log('Player disconnected:', id);
            // Handle the player removal logic here
        });

    
        // Create a sphere for each player
        function createPlayerSphere(id, position) {
            const sphere = document.createElement('a-sphere');
            
            // Check if the current player is the local player
            if (id === socket.id) {
                sphere.setAttribute('color', 'green'); // Local player color
                sphere.setAttribute('radius', '1.0'); // Larger radius for local player
            } else {
                sphere.setAttribute('color', 'red'); // Other players' color
                sphere.setAttribute('radius', '0.5'); // Smaller radius for other players
            }

            sphere.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
            document.querySelector('a-scene').appendChild(sphere);
            players[id] = sphere; // Associate the sphere with the player ID
        }

        

    
        // Joystick setup
        const joystick = nipplejs.create({
            zone: document.getElementById('joystick'),
            mode: 'static',
            position: { left: '50%', bottom: '20px' },
            size: 150,
            color: 'red'
        });
    

        // Joystick movement handling
        joystick.on('move', (evt, data) => {
            const moveDistance = 0.1; // Movement speed
            const angle = data.angle.degree;

            const rad = angle * (Math.PI / 180); // Convert to radians

            // Get the camera's world direction
            const cameraDirection = new THREE.Vector3();
            camera.object3D.getWorldDirection(cameraDirection);
            
            // Project the camera direction onto the X-Z plane (ignore Y)
            cameraDirection.y = 0; // Set Y to zero for 2D movement
            cameraDirection.normalize(); // Normalize to get a unit vector

            // Calculate the movement direction based on joystick input
            const moveDirection = new THREE.Vector3(
                cameraDirection.z * Math.cos(rad) + cameraDirection.x * Math.sin(rad), // Swapped to make 'up' move left
                0, // Keep Y at 0 for 2D movement
                cameraDirection.z * Math.sin(rad) - cameraDirection.x * Math.cos(rad) // Swapped to make 'down' move right
            );


            // Update player position based on the calculated direction
            player.object3D.position.x += moveDirection.x * moveDistance;
            player.object3D.position.z += moveDirection.z * moveDistance;


            // Update the player's sphere position to match the player entity
            const playerSphere = players[socket.id]; // Get the sphere associated with this player
            if (playerSphere) {
                playerSphere.setAttribute('position', `${player.object3D.position.x} ${player.object3D.position.y} ${player.object3D.position.z}`);
            }

            // Emit the new position to the server
            socket.emit('move', { id: socket.id, position: player.object3D.position });
        });


        document.addEventListener('DOMContentLoaded', function () {
            const playerSphere = document.getElementById('player-sphere');
            const distanceText = document.getElementById('distance-text');

            const point1 = document.getElementById('point1');
            const point2 = document.getElementById('point2');
            const point3 = document.getElementById('point3');

            if (!playerSphere || !distanceText || !point1 || !point2 || !point3) {
                console.error('One or more required elements not found!');
                return; // Exit if elements are not found
            }

            function updateDistances() {
                // Get the player's position from the player entity
                const playerX = player.object3D.position.x;
                const playerY = player.object3D.position.y;
                const playerZ = player.object3D.position.z;

                // Get the positions of the points
                const point1X = point1.object3D.position.x;
                const point1Y = point1.object3D.position.y;
                const point1Z = point1.object3D.position.z;

                const point2X = point2.object3D.position.x;
                const point2Y = point2.object3D.position.y;
                const point2Z = point2.object3D.position.z;

                const point3X = point3.object3D.position.x;
                const point3Y = point3.object3D.position.y;
                const point3Z = point3.object3D.position.z;

                // Calculate distances from the player to each point
                const distanceToPoint1 = Math.sqrt(Math.pow(playerX - point1X, 2) + Math.pow(playerY - point1Y, 2) + Math.pow(playerZ - point1Z, 2));
                const distanceToPoint2 = Math.sqrt(Math.pow(playerX - point2X, 2) + Math.pow(playerY - point2Y, 2) + Math.pow(playerZ - point2Z, 2));
                const distanceToPoint3 = Math.sqrt(Math.pow(playerX - point3X, 2) + Math.pow(playerY - point3Y, 2) + Math.pow(playerZ - point3Z, 2));
                
                // Determine the closest point
                let closestPoint = 'None';
                let closestDistance = Infinity;

                if (distanceToPoint1 < closestDistance) {
                    closestDistance = distanceToPoint1;
                    closestPoint = 'Player 1';
                }
                if (distanceToPoint2 < closestDistance) {
                    closestDistance = distanceToPoint2;
                    closestPoint = 'Player 2';
                }
                if (distanceToPoint3 < closestDistance) {
                    closestDistance = distanceToPoint3;
                    closestPoint = 'Player 3';
                }
                

                // Send closest player info to server
                socket.emit('closestPlayer', {
                    id: player.object3D.id, // Player ID (you may need to adjust this if you're not using socket.id)
                    closestPoint: closestPoint,
                    closestDistance: closestDistance
                });

                // Update the text element with the closest point and its distance
                distanceText.setAttribute('value', `You are Supporting: ${closestPoint}\nDistance: ${closestDistance.toFixed(2)}`);


                // Log the closest point and distance
                console.log(`Closest: ${closestPoint}, Distance: ${closestDistance.toFixed(2)}`);
            }

            // Call updateDistances in an animation loop
            function animate() {
                updateDistances();
                requestAnimationFrame(animate);
            }
            animate();
        });




        
        console.log('DOM fully loaded and parsed');
        console.log('Emitting position:', player.object3D.position);
        console.log('Received move for ID:', data.id, 'Position:', data.position);

    </script>
</body>
</html>