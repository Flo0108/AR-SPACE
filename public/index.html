<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>

        /* Full-screen overlay styles */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9); /* Dark semi-transparent background */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 9999; /* Ensure it overlays everything */
            color: white;
        }

        #overlay h2 {
            margin-bottom: 20px;
            font-size: 24px;
        }

        #playerNameInput {
            padding: 10px;
            font-size: 16px;
            margin-bottom: 20px;
            width: 60%;
            max-width: 300px;
            text-align: center;
            border-radius: 5px;
            border: none;
        }

        #joinButton {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }

        #joinButton:hover {
            background-color: #45a049;
        }

        /* Admin control button styles */
        #adminControls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none; /* Hidden by default */
            z-index: 60; /* Video below A-Frame */
        }

        .admin-button {
            padding: 10px 15px;
            font-size: 14px;
            margin: 5px;
            background-color: #FF5733;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 60; /* Video below A-Frame */
        }



        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #000; /* Black background to blend with A-Frame */
            font-family: Arial, sans-serif;
            margin: 0; /* Reset default margin */
            overflow: hidden; /* Hide overflow */
        }

        video {
            width: 100%;
            height: auto;
            position: absolute; /* Position video absolutely */
            top: 0;
            left: 0;
            z-index: 0; /* Video below A-Frame */
        }

        h1 {
            position: absolute; /* Position the heading over the A-Frame */
            top: 20px; /* Space from the top */
            z-index: 10; /* Ensure it stays above the A-Frame */
            color: #fff; /* Change heading color for visibility */
            font-size: 24px; /* Base font size */
        }


        iframe {
            border: none; /* Removes default border */
            border-radius: 8px; /* Optional: Adds rounded corners */
            width: 560px; /* Default width */
            height: 315px; /* Default height */
            position: absolute; /* Absolute positioning */
            top: 80px; /* Space from the top */
            right: 10px;
            z-index: 20; /* Higher z-index to sit above the A-Frame */
        }

        #support-counts {
            position: absolute;
            top: 80px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 21; /* Space from the top */
        }

        #joystick {
            position: fixed;
            bottom: 100px; /* Distance from the bottom of the screen */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Adjust to center precisely */
            width: 150px; /* Default joystick size */
            height: 150px; /* Default joystick size */
            z-index: 30; /* Ensure it appears above other elements */
        }

        a-scene {
            position: absolute; /* Position the A-Frame absolutely */
            top: 0; /* Align to the top */
            left: 0; /* Align to the left */
            width: 100%; /* Full width for A-Frwame */
            height: 100%; /* Full height for A-Frame */
            z-index: 1; /* Lower z-index to place behind other elements */
        }



        /* Media Queries for Responsive Design */
        @media (max-width: 768px) {
            h1 {
                font-size: 20px; /* Smaller font size for mobile */
                top: 10px; /* Adjust position for mobile */
            }


            iframe {
                width: 45%; /* width on mobile */
                height: auto; /* Maintain aspect ratio */
                top: 30px; /* Adjust space from the top */
            }

            #support-counts {
                width: 45%; /* width on mobile */
                height: auto; /* Maintain aspect ratio */
                top: 30px; /* Adjust space from the top */
            }
            
            #joystick {
                width: 60px; /* Smaller joystick size for mobile */
                height: 60px; /* Smaller joystick size for mobile */
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 18px; /* Further reduce font size */
            }

            #joystick {
                width: 80px; /* Even smaller joystick */
                height: 80px; /* Even smaller joystick */
            }
        }

    </style>
    <!-- Include A-Frame library -->
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <!-- Include Nipple.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.8.0/nipplejs.min.js"></script>
    <!-- Include Socket.IO library -->
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>

</head>
<body>
    
    <!-- Audio Element (hidden by default) -->
    <audio id="roundEndSound" src="/soundeffects/new_round.mp3" preload="auto"></audio>


    <!-- Full-screen overlay for name input -->
    <div id="overlay">
        <h2>Enter Your Name</h2>
        <input type="text" id="playerNameInput" placeholder="Your Name">
        <button id="joinButton" onclick="submitName()">Join</button>
    </div>

    <!-- Admin controls only for "camera_master" -->
    <div id="adminControls">
        <button class="admin-button" onclick="triggerSpecialAction()">Level 1</button>
        <button class="admin-button" onclick="triggerSpecialAction2()">Level 2</button>
        <button class="admin-button" onclick="endRound()">End Round</button>
        <button class="admin-button" onclick="endGame()">New Game</button>
    </div>

    <!-- Text for displaying the messages -->
    <div id="voteMessageUI" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: none; /* Initially hidden */
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 30px;
        text-align: center;
        z-index: 9999;
        background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
    ">
        <div style="
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center text vertically within each box */
        ">
            <div id="gameStartedText">ROUND 1</div>
            <div id="voteText">Players may now vote for special effects</div>
        </div>
    </div>

    <div id="voteMessageUI2" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: none; /* Initially hidden */
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 30px;
        text-align: center;
        z-index: 9999;
        background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
    ">
        <div style="
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center text vertically within each box */
        ">
            <div id="gameStartedText">ROUND 2</div>
            <div id="voteText">Players may now vote for Facial Filters</div>
        </div>
    </div>

    <div id="roundEndMessage" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: none; /* Initially hidden */
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 30px;
        text-align: center;
        z-index: 9999;
        background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
    ">
        <div style="
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center text vertically within each box */
        ">
            <div id="gameStartedText">ROUND ENDED</div>
        </div>
    </div>


    <!-- A-Frame Scene -->
    <a-scene embedded>

        <!-- Lights -->
        <a-light type="ambient" color="#FFF" intensity="1"></a-light>
        <a-light type="directional" color="#FFF" intensity="1" position="0 2 0" castShadow="true"></a-light>


        <!-- GLTF Model 1 -->
        <a-entity gltf-model="models/Testarena.glb"
                    visible="true"
                    position="0 0 0"
                    scale="1 1 1"
                    material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                    shadow="receive: true; cast: true">
        </a-entity>


        <!-- Model visibility wrapper - initially hidden -->
        <a-entity id="modelContainer" visible="false">
            <!-- GLTF Model Arena -->
            <a-entity gltf-model="models/Testarenafloor.glb"
                      position="0 0 0"
                      scale="1 1 1"
                      material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                      shadow="receive: true; cast: true"
                      color="#4CC3D9">
            </a-entity>

            <!-- GLTF Model Thumbs Up-->
            <a-entity id="00"
                      class="reactions"
                      gltf-model="models/Thumbs_Up.glb"
                      position="20 0 40"
                      scale="1 1 1"
                      material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                      shadow="receive: true; cast: true"
                      color="#4CC3D9">
            </a-entity>
       
            <!-- GLTF Model Thumbs Down-->
            <a-entity id="01"
                      class="reactions"
                      gltf-model="models/Thumbs_Down.glb"
                      position="40 0 1"
                      scale="1 1 1"
                      material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                      shadow="receive: true; cast: true"
                      color="#4CC3D9">
            </a-entity>
            
            <!-- Objects that change color when looked at -->
            <a-box id="00" class="interactive-box" position="20 5 40" color="purple" scale="7 7 7"></a-box>
            <a-box id="01" class="interactive-box" position="40 5 1" color="purple" scale="7 7 7"></a-box>



            <!-- GLTF Model Thumbs Up-->
            <a-entity id="02"
                      class="reactions"
                      gltf-model="models/Thumbs_Up.glb"
                      position="-20 0 40"
                      scale="1 1 1"
                      material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                      shadow="receive: true; cast: true"
                      color="#4CC3D9">
            </a-entity>
       
            <!-- GLTF Model Thumbs Down-->
            <a-entity id="03"
                      class="reactions"
                      gltf-model="models/Thumbs_Down.glb"
                      position="-40 0 1"
                      scale="1 1 1"
                      material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                      shadow="receive: true; cast: true"
                      color="#4CC3D9">
            </a-entity>


            <!-- Objects that change color when looked at -->
            <a-box id="02" class="interactive-box" position="-20 5 40" color="purple" scale="7 7 7"></a-box>
            <a-box id="03" class="interactive-box" position="-40 5 1" color="purple" scale="7 7 7"></a-box>


            <!-- GLTF Model Thumbs Up-->
            <a-entity id="04"
                      class="reactions"
                      gltf-model="models/Thumbs_Up.glb"
                      position="-20 0 -35"
                      scale="1 1 1"
                      material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                      shadow="receive: true; cast: true"
                      color="#4CC3D9">
            </a-entity>
       
            <!-- GLTF Model Thumbs Down-->
            <a-entity id="05"
                      class="reactions"
                      gltf-model="models/Thumbs_Down.glb"
                      position="20 0 -35"
                      scale="1 1 1"
                      material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                      shadow="receive: true; cast: true"
                      color="#4CC3D9">
            </a-entity>

            <!-- Objects that change color when looked at -->
            <a-box id="04" class="interactive-box" position="-20 5 -35" color="purple" scale="7 7 7"></a-box>
            <a-box id="05" class="interactive-box" position=" 20 5 -35" color="purple" scale="7 7 7"></a-box>
        
        </a-entity>

        <!-- Model visibility wrapper - initially hidden -->
        <a-entity id="modelContainer2" visible="false">
            <!-- GLTF Model 2 -->
            <a-entity gltf-model="models/Testarenafloor2.glb"
                      position="0 0 0"
                      scale="1 1 1"
                      material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1"
                      shadow="receive: true; cast: true"
                      color="#4CC3D9">
                      
            </a-entity>

            <!-- Objects that change color when looked at -->
            <a-box class="interactive-box" position="0 5 -73" color="white" scale="7 7 7"></a-box>
            <a-box class="interactive-box" position="58 5 33" color="white" scale="7 7 7"></a-box>
            <a-box class="interactive-box" position="-58 5 33" color="white" scale="7 7 7"></a-box>
        
        </a-entity>


        <!-- Player Entity -->
        <a-entity id="player" position="0 1 0">
            <!-- Player sphere at height 1 -->
            <a-sphere id="player-sphere" radius="0.5" color="#FF0000"></a-sphere>
            
            <!-- Camera with raycaster -->
            <a-camera id="playerCamera" position="0 15 0" raycaster="objects: .interactive-box; showLine: false; far: 200">
                <!-- Text to display the player name above the avatar -->
                <a-text id="playerNameText" value="" position="0 2 -1" align="center" color="white"></a-text>
            </a-camera>
        </a-entity>


        <!-- Points in the scene (with visual spheres) -->
        <a-entity id="point1" position="-20 2 12.5">
            <a-sphere radius="2" color="#00FF00"></a-sphere> <!-- Green Sphere for Point 2 -->
        </a-entity>
        <a-entity id="point2" position="20 2 12.5">
            <a-sphere radius="2" color="#FFFF00"></a-sphere> <!-- Yellow Sphere for Point 3 -->
        </a-entity>
        <a-entity id="point3" position="0 2 -25">
            <a-sphere radius="2" color="#0000FF"></a-sphere> <!-- Blue Sphere for Point 1 -->
        </a-entity>
        <a-entity id="point4" position="0 0 0">
            <a-sphere radius="2" color="#0000FF"></a-sphere> <!-- Blue Sphere for Point 1 -->
        </a-entity>

    </a-scene>


    <iframe 
        src="https://player.twitch.tv/?channel=flo0oo0oo&parent=ar-space.onrender.com" 
        allowfullscreen="false">
    </iframe>


    <video id="webcam" autoplay playsinline></video>



    <div id="support-counts">
        <p id="None">CURRENT SCORE</p>
        <p id="point1Count">Player 1 Supporters: 0</p>
        <p id="point2Count">Player 2 Supporters: 0</p>
        <p id="point3Count">Player 3 Supporters: 0</p>
    </div>

    <div id="joystick"></div>
    <div id="closest-player">Closest Player: None</div> <!-- New text object for closest player -->

    <script>

        // SET CAMERA HEIGHT BASED ON DEVICE
        // Get the camera entity 
        const playerCamera = document.querySelector("#playerCamera");

        // Function to set camera height based on VR status
        function setCameraHeight(isVR) {
            playerCamera.setAttribute("position", { x: 0, y: isVR ? 1.6 : 15, z: 0 });
        }

        // Listen for entering and exiting VR mode
        const sceneEl = document.querySelector("a-scene");

        sceneEl.addEventListener("enter-vr", () => {
            setCameraHeight(true); // Set height for VR
        });

        sceneEl.addEventListener("exit-vr", () => {
            setCameraHeight(false); // Set height for non-VR
        });

        // Initial height setting for non-VR (e.g., upon loading)
        setCameraHeight(false);






        const socket = io(window.location.origin);

        // Function to handle name submission
        function submitName() {
            const playerName = document.getElementById('playerNameInput').value.trim();

            if (playerName === '') {
                alert("Please enter a name.");
                return;
            }

            document.getElementById('overlay').style.display = 'none';
            document.getElementById('playerNameText').setAttribute('value', playerName);

            if (playerName === 'camera_master') {
                document.getElementById('adminControls').style.display = 'block';
            }
        }
        
        




        // HOST CONTROLLERS

        function triggerSpecialAction() {

            const modelContainer = document.getElementById('modelContainer');
            
            // Get the current visibility (convert string to boolean)
            const currentVisibility = modelContainer.getAttribute('visible');
            
            // Toggle the visibility
            const newVisibility = !currentVisibility; 
            
            // Set the new visibility (true/false, not string)
            modelContainer.setAttribute('visible', newVisibility);

            // Send a message to other clients to sync the visibility
            socket.emit('toggleModelVisibility', newVisibility);

            // Play sound effect if visibility is toggled to true
            if (newVisibility) {

                // Show the message for 5 seconds
                document.getElementById('voteMessageUI').style.display = 'flex';

                // Send a message to other clients to sync the visibility
                socket.emit('showVoteMessage', newVisibility);

                setTimeout(() => {
                    document.getElementById('voteMessageUI').style.display = 'none';
                    // Send a message to other clients to sync the visibility
                    socket.emit('hideVoteMessage', newVisibility);
                }, 5000);
            }
        }

        function triggerSpecialAction2() {
            const modelContainer = document.getElementById('modelContainer2');
            
            // Get the current visibility (convert string to boolean)
            const currentVisibility = modelContainer.getAttribute('visible');
            
            // Toggle the visibility
            const newVisibility = !currentVisibility; // Just toggle the boolean value
            
            // Set the new visibility (true/false, not string)
            modelContainer.setAttribute('visible', newVisibility);

            // Send a message to other clients to sync the visibility
            socket.emit('toggleModelVisibility2', newVisibility);


            // Play sound effect if visibility is toggled to true
            if (newVisibility) {
                // Show the message for 5 seconds
                document.getElementById('voteMessageUI2').style.display = 'flex';
                setTimeout(() => {
                    document.getElementById('voteMessageUI2').style.display = 'none';
                }, 5000);
            }
        }

        function endRound() {
            // Send a message to other clients to sync the visibility
            socket.emit('endRound');
            
            // Play the round end sound
            const roundEndSound = document.getElementById('roundEndSound');
            roundEndSound.play();

            const voteMessageUI = document.getElementById('roundEndMessage');
            voteMessageUI.style.display = 'flex'; // Show the message

            setTimeout(() => {
                document.getElementById('roundEndMessage').style.display = 'none'; // Hide the message after 5 seconds
            }, 5000);
        }

        function endGame() {
            // Send a message to other clients to sync the visibility
            socket.emit('endGame');
        }




        

        // Client-side (JavaScript)
        socket.on('updateModelVisibility', (newVisibility) => {
            const modelContainer = document.getElementById('modelContainer');
            modelContainer.setAttribute('visible', newVisibility);
        });
        
        // Client-side (JavaScript)
        socket.on('updateModelVisibility2', (newVisibility) => {
            const modelContainer = document.getElementById('modelContainer2');
            modelContainer.setAttribute('visible', newVisibility);
        });



        // Listen for the toggle visibility sync
        socket.on('toggleModelVisibility', (newVisibility) => {
            const modelContainer = document.getElementById('modelContainer');
            modelContainer.setAttribute('visible', newVisibility);
        });

        // Listen for the toggle visibility sync
        socket.on('toggleModelVisibility2', (newVisibility) => {
            const modelContainer = document.getElementById('modelContainer2');
            modelContainer.setAttribute('visible', newVisibility);
        });



        // Listen for showing the vote message UI
        socket.on('showVoteMessage', () => {
            const voteMessageUI = document.getElementById('voteMessageUI');
            voteMessageUI.style.display = 'flex'; // Show the message
        });

        // Listen for hiding the vote message UI
        socket.on('hideVoteMessage', () => {
            const voteMessageUI = document.getElementById('voteMessageUI');
            voteMessageUI.style.display = 'none'; // Hide the message
        });

        socket.on('roundEnded', () => {

            const roundEndSound = document.getElementById('roundEndSound');
            roundEndSound.play();

            const voteMessageUI = document.getElementById('roundEndMessage');
            voteMessageUI.style.display = 'flex'; // Hide the message
            
            setTimeout(() => {
                    document.getElementById('roundEndMessage').style.display = 'none';
                }, 5000);
        });



        AFRAME.registerComponent('rotate', {
                schema: {
                    speed: {type: 'number', default: 1} // Rotation speed
                },
                tick: function () {
                    const el = this.el; // Reference to the entity
                    const data = this.data; // Component data
                    el.object3D.rotation.y += data.speed * 0.01; // Adjust speed as needed
                }
            });

        // Access the user's webcam
        const video = document.querySelector('#webcam');

        navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment' } // 'user' for front camera, 'environment' for rear camera
        })
        .then(function(stream) {
            video.srcObject = stream;
            video.play();
        })
        .catch(function(err) {
            console.error("Error accessing webcam: " + err);
        });








        let players = {};
        const player = document.getElementById('player'); // Get player entity
        const camera = player.querySelector('a-camera');  // Camera within player
        const closestPlayerDiv = document.getElementById('closest-player'); // Div for closest player info

        // Points in the scene
        const points = [
            { id: 'point1', element: document.getElementById('point1') },
            { id: 'point2', element: document.getElementById('point2') },
            { id: 'point3', element: document.getElementById('point3') },
            { id: 'point4', element: document.getElementById('point4') }
        ];

        // Handle the current players on initial connection
        socket.on('currentPlayers', (serverPlayers) => {
            for (const id in serverPlayers) {
                if (!players[id]) {
                    createPlayerSphere(id, serverPlayers[id].position);
                }
            }
        });

        // Handle new player joining
        socket.on('newPlayer', (data) => {
            createPlayerSphere(data.id, data.position);
        });

        // Handle player movement
        socket.on('move', (data) => {
            if (players[data.id]) {
                players[data.id].setAttribute('position', `${data.position.x} ${data.position.y} ${data.position.z}`);
            }
        });

        // Handle player disconnect
        socket.on('removePlayer', (id) => {
            if (players[id]) {
                players[id].parentNode.removeChild(players[id]);
                delete players[id];
            }
        });



        // Create a sphere for each player
        function createPlayerSphere(id, position) {
            const sphere = document.createElement('a-sphere');
            
            // Check if the current player is the local player
            if (id === socket.id) {
                sphere.setAttribute('color', 'green'); // Local player color
                sphere.setAttribute('radius', '1');
            } else {
                sphere.setAttribute('color', 'red'); // Other players color
                sphere.setAttribute('radius', '0.5');
            }
            
            sphere.setAttribute('position', position);
            sphere.setAttribute('id', id);
            document.querySelector('a-scene').appendChild(sphere);
            players[id] = sphere; // Store the sphere for future reference
        }



        // Calculate and display the closest point
        function updateClosestPoint() {
            const playerPos = player.getAttribute('position');
            let closestPoint = null;
            let closestDistance = Infinity;

            // Iterate over defined points to find the closest one
            points.forEach(point => {
                const pointPos = point.element.getAttribute('position');
                const distance = Math.sqrt(
                    Math.pow(pointPos.x - playerPos.x, 2) +
                    Math.pow(pointPos.y - playerPos.y, 2) +
                    Math.pow(pointPos.z - playerPos.z, 2)
                );

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPoint = point.id; // Keep track of the closest point
                }
            });
        
            // Send the closest point to the server
            socket.emit('updateSupportPoint', {
                playerId: socket.id,  // Send player ID to the server
                supportPoint: closestPoint // Send closest point ID
            });
        
        }

        // Update closest point every second
        setInterval(updateClosestPoint, 2000);


    
        // Joystick setup
        const joystick = nipplejs.create({
            zone: document.getElementById('joystick'),
            mode: 'static',
            position: { left: '50%', bottom: '20px' },
            size: 150,
            color: 'red'
        });
    
        let joystickActive = false; // Track joystick activity
        let currentMoveDirection = new THREE.Vector3(); // Store the current move direction

        // Joystick movement handling
        joystick.on('move', (evt, data) => {
            joystickActive = true; // Joystick is being manipulated
            const moveDistance = 0.6; // Movement speed
            const angle = data.angle.degree;

            const rad = angle * (Math.PI / 180); // Convert to radians

            // Get the camera's world direction
            const cameraDirection = new THREE.Vector3();
            camera.object3D.getWorldDirection(cameraDirection);
            
            // Project the camera direction onto the X-Z plane (ignore Y)
            cameraDirection.y = 0; // Set Y to zero for 2D movement
            cameraDirection.normalize(); // Normalize to get a unit vector

            // Calculate the movement direction based on joystick input
            currentMoveDirection.set(
                cameraDirection.z * Math.cos(rad) + cameraDirection.x * -Math.sin(rad), // Swapped to make 'up' move left
                0, // Keep Y at 0 for 2D movement
                cameraDirection.z * -Math.sin(rad) - cameraDirection.x * Math.cos(rad) // Swapped to make 'down' move right
            );
        });

        // Event when joystick is released
        joystick.on('end', () => {
            joystickActive = false; // Joystick is not being manipulated
            currentMoveDirection.set(0, 0, 0); // Reset direction
        });

        // Update loop
        function update() {
            if (joystickActive) {
                const moveDistance = 0.25; // Movement speed

                // Update player position based on the calculated direction
                player.object3D.position.x += currentMoveDirection.x * moveDistance;
                player.object3D.position.z += currentMoveDirection.z * moveDistance;

                // Update the player's sphere position to match the player entity
                const playerSphere = players[socket.id]; // Get the sphere associated with this player
                if (playerSphere) {
                    playerSphere.setAttribute('position', `${player.object3D.position.x} ${player.object3D.position.y} ${player.object3D.position.z}`);
                }

                // Emit the new position to the server
                socket.emit('move', { id: socket.id, position: player.object3D.position });
            }

            requestAnimationFrame(update); // Continue the update loop
        }

        // Start the update loop
        update();





        // Get the model container element
        const modelContainer = document.getElementById('modelContainer');

        // Find all elements within the container with the class 'reactions'
        const reactionModels = modelContainer.querySelectorAll('.reactions');

        // Loop through each element and print it
        reactionModels.forEach((model, index) => {
            console.log(`Element ${index + 1}:`, model);
        });







        // Select all box objects with the class 'interactive-box'
        const boxes = document.querySelectorAll('.interactive-box');
        const reactions = document.querySelectorAll('.reactions');

        console.log(reactions)

        // Loop through each box and add event listeners
        boxes.forEach((box) => {
            let isIntersected = false;

            // Store the original color in a dataset attribute
            box.dataset.originalColor = box.getAttribute('color');


            // Event listener for intersection
            box.addEventListener('raycaster-intersected', () => {
                
                console.log(Math.trunc(box.id))
                console.log(reactions[Math.trunc(box.id)])

                reactions[Math.trunc(box.id)].setAttribute('material', 'color', 'yellow')
                box.setAttribute('material', 'color', 'yellow');
            });


            // Event listener for clearing intersection
            box.addEventListener('raycaster-intersected-cleared', () => {
                // Reset to original color
                const originalColor = box.dataset.originalColor;
                box.setAttribute('material', 'color', originalColor);
            });

        });











        // Recursive function to subdivide and collect triangles
        function subdivideAndCollectTriangles(x1, y1, x2, y2, x3, y3, depth, scaleFactor, triangles) {
        if (depth === 0) {
            triangles.push(scaleTriangle(x1, y1, x2, y2, x3, y3, scaleFactor));
            return;
        }

        const midX1 = (x1 + x2) / 2;
        const midY1 = (y1 + y2) / 2;
        const midX2 = (x2 + x3) / 2;
        const midY2 = (y2 + y3) / 2;
        const midX3 = (x3 + x1) / 2;
        const midY3 = (y3 + y1) / 2;

        subdivideAndCollectTriangles(x1, y1, midX1, midY1, midX3, midY3, depth - 1, scaleFactor, triangles);
        subdivideAndCollectTriangles(midX1, midY1, x2, y2, midX2, midY2, depth - 1, scaleFactor, triangles);
        subdivideAndCollectTriangles(midX3, midY3, midX2, midY2, x3, y3, depth - 1, scaleFactor, triangles);
        subdivideAndCollectTriangles(midX1, midY1, midX2, midY2, midX3, midY3, depth - 1, scaleFactor, triangles);
        }

        // Scale a triangle toward its centroid
        function scaleTriangle(x1, y1, x2, y2, x3, y3, scaleFactor) {
        const centerX = (x1 + x2 + x3) / 3;
        const centerY = (y1 + y2 + y3) / 3;
        return [
            centerX + (x1 - centerX) * scaleFactor,
            centerY + (y1 - centerY) * scaleFactor,
            centerX + (x2 - centerX) * scaleFactor,
            centerY + (y2 - centerY) * scaleFactor,
            centerX + (x3 - centerX) * scaleFactor,
            centerY + (y3 - centerY) * scaleFactor
        ];
        }

        // Create a triangle element in A-Frame
        function createATriangle(scene, x1, y1, x2, y2, x3, y3) {
            const triangle = document.createElement('a-triangle');
            triangle.setAttribute('vertex-a', `${x1 / 100} 0 ${y1 / 100}`);
            triangle.setAttribute('vertex-b', `${x2 / 100} 0 ${y2 / 100}`);
            triangle.setAttribute('vertex-c', `${x3 / 100} 0 ${y3 / 100}`);
            scene.appendChild(triangle);
            return triangle;
        }

        // Draw and display triangles based on subdivision depth
        function drawAndDisplayTriangles(scene, subdivisionDepth, x1, y1, x2, y2, x3, y3, triangleGroup, triangleColor) {
            const triangles = [];

            // Collect triangles
            subdivideAndCollectTriangles(x1, y1, x2, y2, x3, y3, subdivisionDepth, 0.9, triangles);

            // Remove the previous triangles from the group
            triangleGroup.forEach(triangle => triangle.parentNode.removeChild(triangle));

            // Clear the triangle group array
            triangleGroup.length = 0;

            // Display triangles in A-Frame
            triangles.forEach(triangle => {
                const newTriangle = createATriangle(scene, ...triangle);
                newTriangle.setAttribute('material', `color: hsl(${triangleColor + Math.random() * 40}, 50%, 50%); side: double`);
                triangleGroup.push(newTriangle);
            });
        }

        // Initial triangle coordinates for three positions
        const width = 4000;  // Canvas width for 2D drawing
        const height = 4000; // Canvas height for 2D drawing

        xpos = -(width / 2)
        ypos = - height * 1.3


        const varxa = xpos
        const varya = ypos

        const varxb = xpos + width / 2
        const varyb = ypos + height

        const varxc = xpos - (width / 2)
        const varyc = ypos + height

        // Position 1
        const x1a = width / 2 + varxa, y1a = 0 + varya;
        const x2a = 0 + varxa, y2a = height - 0 + varya;
        const x3a = width - 0 + varxa, y3a = height - 0 + varya;

        const x1b = width / 2 + varxb, y1b = 0 + varyb;
        const x2b = 0 + varxb, y2b = height - 0 + varyb;
        const x3b = width - 0 + varxb, y3b = height - 0 + varyb;

        // Position 3
        const x1c = width / 2 + varxc, y1c = 0 + varyc;
        const x2c = 0 + varxc, y2c = height - 0 + varyc;
        const x3c = width - 0 + varxc, y3c = height - 0 + varyc;

        const colora = 120
        const colorb = 700
        const colorc = 1400

        // Create arrays to hold the triangles for each position
        const triangleGroup1 = [];
        const triangleGroup2 = [];
        const triangleGroup3 = [];



        // Listen for support point updates from the server
        socket.on('supportPointUpdate', (data) => {
            const { pointCounts, playerId, supportPoint, playerScores } = data;

            console.log(playerScores.point1)
            console.log(playerScores.point2)
            console.log(playerScores.point3)

            // Update the HTML with the latest counts
            document.getElementById('point1Count').textContent = `Player 1 Supporters: ${pointCounts.point1}`;
            document.getElementById('point2Count').textContent = `Player 2 Supporters: ${pointCounts.point2}`;
            document.getElementById('point3Count').textContent = `Player 3 Supporters: ${pointCounts.point3}`;

            const absval = pointCounts.point1 + pointCounts.point2 + pointCounts.point3

            const val1 = Math.trunc(((pointCounts.point1 / absval) * 2) + playerScores.point1)
            const val2 = Math.trunc(((pointCounts.point2 / absval) * 2) + playerScores.point2)
            const val3 = Math.trunc(((pointCounts.point3 / absval) * 2) + playerScores.point3)

            // Initial draw with subdivision depth of 3
            drawAndDisplayTriangles(document.querySelector('a-scene'), val3, x1a, y1a, x2a, y2a, x3a, y3a, triangleGroup1, colora);
            drawAndDisplayTriangles(document.querySelector('a-scene'), val2, x1b, y1b, x2b, y2b, x3b, y3b, triangleGroup2, colorb);
            drawAndDisplayTriangles(document.querySelector('a-scene'), val1 , x1c, y1c, x2c, y2c, x3c, y3c, triangleGroup3, colorc);

        });
        
        console.log('DOM fully loaded and parsed');
    </script>
</body>
</html>