<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Multiplayer VR Sample</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/nipplejs/dist/nipplejs.css" />
    <script src="https://unpkg.com/nipplejs/dist/nipplejs.js"></script>
    <style>
        #joystick {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
        }

        video {
            width: 640px; /* Set appropriate width */
            height: auto; /* Set height to auto */
            position: absolute; /* Keep it hidden but still rendering */
            top: -9999px; /* Move it off-screen */
        }
    </style>
</head>
<body>
    <a-scene fog="type: linear; color: #AAB7B8; near: 10; far: 50">

        <a-assets>
            <img id="groundTexture" src="path/to/ground-texture.jpg">
            <img id="skyTexture" src="path/to/skybox.jpg">
        </a-assets>

        <!-- Sky and Lighting -->
        <a-sky src="#skyTexture"></a-sky>
        <a-light type="ambient" color="#888"></a-light>
        <a-light type="directional" position="10 10 0" intensity="2"></a-light>

        <!-- Ground Plane -->
        <a-plane rotation="-90 0 0" width="30" height="30" src="#groundTexture" repeat="10 10"></a-plane>

        <!-- Load the model -->
        <a-entity gltf-model="models/Test.glb" position="0 0.5 0" scale="1 1 1"></a-entity>
        <a-entity gltf-model="models/Floor.glb" position="0 1 0" scale="1 1 1"></a-entity>

        <!-- Video planes for streaming -->
        <a-plane id="videoPlane" rotation="0 0 0" width="5" height="3" position="0 4 -10" visible="false"></a-plane>
        <a-plane id="videoPlane1" rotation="0 120" width="5" height="3" position="-10 4 10" visible="false"></a-plane>
        <a-plane id="videoPlane2" rotation="0 -120 0" width="5" height="3" position="10 4 10" visible="false"></a-plane>

        <!-- Player template -->
        <a-entity id="player" position="0 1.6 0">
            <a-camera></a-camera>
        </a-entity>

    </a-scene>

    <div id="joystick"></div>

    <!-- Hidden video element to capture webcam stream -->
    <video id="videoElement" autoplay playsinline style="display:none;"></video>


    <script>
        const socket = io(window.location.origin);
        let players = {};
        let firstPlayerId = null; // To keep track of the first player who connects
        const player = document.getElementById('player');
        const camera = player.querySelector('a-camera');

        // Capture the video stream from the webcam
        async function startStreaming() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                const videoElement = document.getElementById('videoElement');
                videoElement.srcObject = stream;
                await videoElement.play();
                applyVideoTexture(); // Call function to apply video texture once stream starts
            } catch (err) {
                console.error("Error accessing webcam: ", err);
            }
        }

        // Apply video texture to the planes
        function applyVideoTexture() {
            const videoElement = document.getElementById('videoElement');

            // Set video texture for each plane
            document.querySelectorAll('a-plane').forEach(videoPlane => {
                videoPlane.setAttribute('material', `src: #videoElement; repeat: 1 1;`);
                videoPlane.setAttribute('visible', true); // Make the plane visible
            });
        }

        // Sync the streaming player based on connection order
        socket.on('connect', () => {
            if (!firstPlayerId) {
                firstPlayerId = socket.id; // Set the first player to stream
                socket.emit('setStreamingPlayer', firstPlayerId);
            }
        });

        // Set up event listeners for syncing the streaming player
        socket.on('setStreamingPlayer', (streamingPlayerId) => {
            if (socket.id === streamingPlayerId) {
                startStreaming();  // Only start streaming if this player is designated to stream
            }
        });

        // If the streaming player disconnects, hide the video plane for everyone
        socket.on('streamingPlayerLeft', () => {
            document.querySelectorAll('a-plane').forEach(videoPlane => {
                videoPlane.setAttribute('visible', false);
            });
        });

        // Update the current streaming player when notified by the server
        socket.on('updateStreamingPlayer', (streamingPlayerId) => {
            if (socket.id !== streamingPlayerId) {
                document.querySelectorAll('a-plane').forEach(videoPlane => {
                    videoPlane.setAttribute('material', 'src', '#videoElement'); // Ensure the video texture is applied
                    videoPlane.setAttribute('visible', true); // Make the plane visible for all other players
                });
            }
        });

        // Joystick setup
        const joystick = nipplejs.create({
            zone: document.getElementById('joystick'),
            mode: 'static',
            position: { left: '50%', bottom: '50%' },
            size: 100,
            color: 'white'
        });

        // Function to get the camera's forward and right direction vectors
        function getCameraDirection() {
            const cameraRotation = camera.getAttribute('rotation');
            const yaw = THREE.MathUtils.degToRad(cameraRotation.y); // Convert yaw to radians

            // Calculate forward and right vectors based on yaw
            const forwardVector = new THREE.Vector3(Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
            const rightVector = new THREE.Vector3(forwardVector.z, 0, -forwardVector.x).normalize(); // Perpendicular to forward

            return { forward: forwardVector, right: rightVector };
        }

        // Joystick movement handler
        joystick.on('move', (evt, data) => {
            // Get the camera's yaw (rotation around the y-axis)
            const cameraRotation = camera.getAttribute('rotation');
            const yaw = THREE.MathUtils.degToRad(cameraRotation.y); // Convert yaw to radians

            // Calculate the forward direction based on camera's yaw
            const forwardVector = new THREE.Vector2(Math.sin(yaw), -Math.cos(yaw)); // Camera's forward in 2D

            // Calculate the joystick movement vector
            const joystickVector = new THREE.Vector2(data.vector.x, data.vector.y); // x = left/right, y = forward/backward

            // Adjust joystick input to movement vector
            const movementVector = forwardVector.clone().multiplyScalar(joystickVector.y); // Move forward/backward
            const rightVector = new THREE.Vector2(forwardVector.y, -forwardVector.x); // Perpendicular to forward for right movement

            // Move right/left based on joystick input
            movementVector.add(rightVector.multiplyScalar(joystickVector.x)); // Add right movement

            // Get the current player position
            const playerPos = player.getAttribute('position');

            // Update position based on the movement vector
            const newPosition = {
                x: playerPos.x - movementVector.x * 0.1, // Scale movement for control
                y: playerPos.y, // Maintain height
                z: playerPos.z + movementVector.y * 0.1 // Scale movement for control
            };

            // Update the player's position
            player.setAttribute('position', newPosition);

            // Send updated position to server
            sendMove(newPosition);
        });

        // Initialize and update player positions in scene
        socket.on('currentPlayers', (currentPlayers) => {
            players = currentPlayers;
            Object.keys(players).forEach(id => {
                if (id !== socket.id) addPlayer(id, players[id].position);
            });
        });

        // Player management: add, remove, and update players in scene
        socket.on('newPlayer', (data) => {
            addPlayer(data.id, data.position);
        });
        socket.on('removePlayer', (id) => {
            const player = document.getElementById(id);
            if (player) player.remove();
        });
        socket.on('move', (data) => {
            const otherPlayer = document.getElementById(data.id);
            if (otherPlayer) {
                otherPlayer.setAttribute('position', data.position);
            }
        });

        function addPlayer(id, position) {
            const el = document.createElement('a-sphere');
            el.setAttribute('id', id);
            el.setAttribute('position', position);
            el.setAttribute('radius', 0.3);
            el.setAttribute('color', '#FF0000');

            // Append player entity to the scene
            document.querySelector('a-scene').appendChild(el);
        }

        function sendMove(position) {
            socket.emit('move', { id: socket.id, position: position });
        }

        // Start the socket connection
        socket.on('disconnect', () => {
            if (firstPlayerId === socket.id) {
                socket.emit('streamingPlayerLeft'); // Notify others that the first player left
                firstPlayerId = null; // Reset the first player id
            }
        });

    </script>
</body>
</html>
