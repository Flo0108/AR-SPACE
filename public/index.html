<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #000; /* Black background to blend with A-Frame */
            font-family: Arial, sans-serif;
            margin: 0; /* Reset default margin */
            overflow: hidden; /* Hide overflow */
        }

        video {
            width: 100%;
            height: auto;
            position: absolute; /* Position video absolutely */
            top: 0;
            left: 0;
            z-index: 0; /* Video below A-Frame */
        }

        h1 {
            position: absolute; /* Position the heading over the A-Frame */
            top: 20px; /* Space from the top */
            z-index: 10; /* Ensure it stays above the A-Frame */
            color: #fff; /* Change heading color for visibility */
            font-size: 24px; /* Base font size */
        }

        #closest-player {
            position: fixed;
            bottom: 220px; /* Space from the top */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Adjust to center precisely */
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 10; /* Ensure it appears above the A-Frame */
            font-size: 18px;
        }

        iframe {
            border: none; /* Removes default border */
            border-radius: 8px; /* Optional: Adds rounded corners */
            width: 560px; /* Default width */
            height: 315px; /* Default height */
            position: absolute; /* Absolute positioning */
            top: 80px; /* Space from the top */
            z-index: 20; /* Higher z-index to sit above the A-Frame */
        }

        #joystick {
            position: fixed;
            bottom: 100px; /* Distance from the bottom of the screen */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Adjust to center precisely */
            width: 150px; /* Default joystick size */
            height: 150px; /* Default joystick size */
            z-index: 30; /* Ensure it appears above other elements */
        }

        a-scene {
            position: absolute; /* Position the A-Frame absolutely */
            top: 0; /* Align to the top */
            left: 0; /* Align to the left */
            width: 100%; /* Full width for A-Frame */
            height: 100%; /* Full height for A-Frame */
            z-index: 1; /* Lower z-index to place behind other elements */
        }

        /* Media Queries for Responsive Design */
        @media (max-width: 768px) {
            h1 {
                font-size: 20px; /* Smaller font size for mobile */
                top: 10px; /* Adjust position for mobile */
            }

            #closest-player {
                font-size: 16px; /* Smaller font size for mobile */
            }

            iframe {
                width: 60%; /* width on mobile */
                height: auto; /* Maintain aspect ratio */
                top: 50px; /* Adjust space from the top */
            }

            #joystick {
                width: 100px; /* Smaller joystick size for mobile */
                height: 100px; /* Smaller joystick size for mobile */
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 18px; /* Further reduce font size */
            }

            #joystick {
                width: 80px; /* Even smaller joystick */
                height: 80px; /* Even smaller joystick */
            }
        }

    </style>
    <!-- Include A-Frame library -->
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <!-- Include Nipple.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.8.0/nipplejs.min.js"></script>
    <!-- Include Socket.IO library -->
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>

</head>
<body>


    <!-- A-Frame Scene -->
    <a-scene embedded>

        <!-- Lights -->
        <a-light type="ambient" color="#FFF" intensity="1"></a-light>
        <a-light type="directional" color="#FFF" intensity="1" position="0 2 0" castShadow="true"></a-light>
        

        <!-- Load the model -->
        <a-entity 
            gltf-model="models/Testarena.glb" 
            position="0 0.5 0" 
            scale="1 1 1" 
            material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1" 
            shadow="receive: true; cast: true">
        </a-entity>

        <!-- Load the model -->
        <a-entity 
            gltf-model="models/Testarenafloor.glb" 
            position="0 0.5 0" 
            scale="1 1 1" 
            material="shader: standard; emissive: #FF0000; emissiveIntensity: 0.1" 
            shadow="receive: true; cast: true"
            color="#4CC3D9" 
            animation="property: rotation; to: 0 360 0; loop: true; dur: 100000;">
        </a-entity>

        <!-- Player Entity -->
        <a-entity id="player" position="0 1 0">  <!-- Player sphere at height 1 -->
            <a-sphere id="player-sphere" radius="0.5" color="#FF0000"></a-sphere> <!-- Optional player sphere -->
            <a-camera position="0 25 0"></a-camera>  <!-- Camera at height 15 (1 + 14) -->
        </a-entity>

        <!-- Points in the scene (with visual spheres) -->
        <a-entity id="point1" position="-10 2 10">
            <a-sphere radius="0.01" color="#00FF00"></a-sphere> <!-- Green Sphere for Point 2 -->
        </a-entity>
        <a-entity id="point2" position="10 2 10">
            <a-sphere radius="0.01" color="#FFFF00"></a-sphere> <!-- Yellow Sphere for Point 3 -->
        </a-entity>
        <a-entity id="point3" position="0 2 -10">
            <a-sphere radius="0.01" color="#0000FF"></a-sphere> <!-- Blue Sphere for Point 1 -->
        </a-entity>


    </a-scene>


    <iframe 
        src="https://player.twitch.tv/?channel=flo0oo0oo&parent=ar-space.onrender.com" 
        allowfullscreen="false">
    </iframe>


    <video id="webcam" autoplay playsinline></video>









    <div id="joystick"></div>
    <div id="closest-player">Closest Player: None</div> <!-- New text object for closest player -->

    <script>


        AFRAME.registerComponent('rotate', {
                schema: {
                    speed: {type: 'number', default: 1} // Rotation speed
                },
                tick: function () {
                    const el = this.el; // Reference to the entity
                    const data = this.data; // Component data
                    el.object3D.rotation.y += data.speed * 0.01; // Adjust speed as needed
                }
            });

        // Access the user's webcam
        const video = document.querySelector('#webcam');

        navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment' } // 'user' for front camera, 'environment' for rear camera
        })
        .then(function(stream) {
            video.srcObject = stream;
            video.play();
        })
        .catch(function(err) {
            console.error("Error accessing webcam: " + err);
        });

            
        const socket = io(window.location.origin);
        let players = {};
        const player = document.getElementById('player'); // Get player entity
        const camera = player.querySelector('a-camera');  // Camera within player
        const closestPlayerDiv = document.getElementById('closest-player'); // Div for closest player info

        // Points in the scene
        const points = [
            { id: 'PLAYER 1', element: document.getElementById('point1') },
            { id: 'PLAYER 2', element: document.getElementById('point2') },
            { id: 'PLAYER 3', element: document.getElementById('point3') }
        ];

        // Handle the current players on initial connection
        socket.on('currentPlayers', (serverPlayers) => {
            for (const id in serverPlayers) {
                if (!players[id]) {
                    createPlayerSphere(id, serverPlayers[id].position);
                }
            }
        });

        // Handle new player joining
        socket.on('newPlayer', (data) => {
            createPlayerSphere(data.id, data.position);
        });

        // Handle player movement
        socket.on('move', (data) => {
            if (players[data.id]) {
                players[data.id].setAttribute('position', `${data.position.x} ${data.position.y} ${data.position.z}`);
            }
        });

        // Handle player disconnect
        socket.on('removePlayer', (id) => {
            if (players[id]) {
                players[id].parentNode.removeChild(players[id]);
                delete players[id];
            }
        });

        // Create a sphere for each player
        function createPlayerSphere(id, position) {
            const sphere = document.createElement('a-sphere');
            
            // Check if the current player is the local player
            if (id === socket.id) {
                sphere.setAttribute('color', 'green'); // Local player color
                sphere.setAttribute('radius', '1');
            } else {
                sphere.setAttribute('color', 'red'); // Other players color
                sphere.setAttribute('radius', '0.5');
            }
            
            sphere.setAttribute('position', position);
            sphere.setAttribute('id', id);
            document.querySelector('a-scene').appendChild(sphere);
            players[id] = sphere; // Store the sphere for future reference
        }

        // Calculate and display the closest point
        function updateClosestPoint() {
            const playerPos = player.getAttribute('position');
            let closestPoint = null;
            let closestDistance = Infinity;

            // Iterate over defined points to find the closest one
            points.forEach(point => {
                const pointPos = point.element.getAttribute('position');
                const distance = Math.sqrt(
                    Math.pow(pointPos.x - playerPos.x, 2) +
                    Math.pow(pointPos.y - playerPos.y, 2) +
                    Math.pow(pointPos.z - playerPos.z, 2)
                );

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPoint = point.id; // Keep track of the closest point
                }
            });

            // Update the closest point text
            closestPlayerDiv.textContent = closestPoint ? `You are supporting: ${closestPoint}` : 'You are supporting: None';
        }

        // Update closest point every second
        setInterval(updateClosestPoint, 2000);


    
        // Joystick setup
        const joystick = nipplejs.create({
            zone: document.getElementById('joystick'),
            mode: 'static',
            position: { left: '50%', bottom: '20px' },
            size: 150,
            color: 'red'
        });
    
        let joystickActive = false; // Track joystick activity
        let currentMoveDirection = new THREE.Vector3(); // Store the current move direction

        // Joystick movement handling
        joystick.on('move', (evt, data) => {
            joystickActive = true; // Joystick is being manipulated
            const moveDistance = 0.3; // Movement speed
            const angle = data.angle.degree;

            const rad = angle * (Math.PI / 180); // Convert to radians

            // Get the camera's world direction
            const cameraDirection = new THREE.Vector3();
            camera.object3D.getWorldDirection(cameraDirection);
            
            // Project the camera direction onto the X-Z plane (ignore Y)
            cameraDirection.y = 0; // Set Y to zero for 2D movement
            cameraDirection.normalize(); // Normalize to get a unit vector

            // Calculate the movement direction based on joystick input
            currentMoveDirection.set(
                cameraDirection.z * Math.cos(rad) + cameraDirection.x * -Math.sin(rad), // Swapped to make 'up' move left
                0, // Keep Y at 0 for 2D movement
                cameraDirection.z * -Math.sin(rad) - cameraDirection.x * Math.cos(rad) // Swapped to make 'down' move right
            );
        });

        // Event when joystick is released
        joystick.on('end', () => {
            joystickActive = false; // Joystick is not being manipulated
            currentMoveDirection.set(0, 0, 0); // Reset direction
        });

        // Update loop
        function update() {
            if (joystickActive) {
                const moveDistance = 0.1; // Movement speed

                // Update player position based on the calculated direction
                player.object3D.position.x += currentMoveDirection.x * moveDistance;
                player.object3D.position.z += currentMoveDirection.z * moveDistance;

                // Update the player's sphere position to match the player entity
                const playerSphere = players[socket.id]; // Get the sphere associated with this player
                if (playerSphere) {
                    playerSphere.setAttribute('position', `${player.object3D.position.x} ${player.object3D.position.y} ${player.object3D.position.z}`);
                }

                // Emit the new position to the server
                socket.emit('move', { id: socket.id, position: player.object3D.position });
            }

            requestAnimationFrame(update); // Continue the update loop
        }

        // Start the update loop
        update();






        
        console.log('DOM fully loaded and parsed');
        console.log('Emitting position:', player.object3D.position);
        console.log('Received move for ID:', data.id, 'Position:', data.position);

    </script>
</body>
</html>